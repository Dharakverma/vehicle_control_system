var dataJson = {"arch":{"ispc":true,"isunix":false,"ismac":false},"build":"controller","ref":false,"files":[{"name":"ert_main.c","type":"source","group":"main","path":"C:\\Users\\Abhishek\\Downloads\\Formula\\git\\vehicle_control_system\\src\\controller_ert_rtw","tag":"","groupDisplay":"Main file","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: ert_main.c\r\n *\r\n * Code generated for Simulink model 'controller'.\r\n *\r\n * Model version                  : 1.9\r\n * Simulink Coder version         : 9.8 (R2022b) 13-May-2022\r\n * C/C++ source code generated on : Sat Jan 28 16:12:49 2023\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include <stddef.h>\r\n#include <stdio.h>            /* This example main program uses printf/fflush */\r\n#include \"controller.h\"                /* Model header file */\r\n\r\n/*\r\n * Associating rt_OneStep with a real-time clock or interrupt service routine\r\n * is what makes the generated code \"real-time\".  The function rt_OneStep is\r\n * always associated with the base rate of the model.  Subrates are managed\r\n * by the base rate from inside the generated code.  Enabling/disabling\r\n * interrupts and floating point context switches are target specific.  This\r\n * example code indicates where these should take place relative to executing\r\n * the generated code step function.  Overrun behavior should be tailored to\r\n * your application needs.  This example simply sets an error status in the\r\n * real-time model and returns from rt_OneStep.\r\n */\r\nvoid rt_OneStep(void);\r\nvoid rt_OneStep(void)\r\n{\r\n  static boolean_T OverrunFlag = false;\r\n\r\n  /* Disable interrupts here */\r\n\r\n  /* Check for overrun */\r\n  if (OverrunFlag) {\r\n    rtmSetErrorStatus(controller_M, \"Overrun\");\r\n    return;\r\n  }\r\n\r\n  OverrunFlag = true;\r\n\r\n  /* Save FPU context here (if necessary) */\r\n  /* Re-enable timer or interrupt here */\r\n  /* Set model inputs here */\r\n\r\n  /* Step the model */\r\n  controller_step();\r\n\r\n  /* Get model outputs here */\r\n\r\n  /* Indicate task complete */\r\n  OverrunFlag = false;\r\n\r\n  /* Disable interrupts here */\r\n  /* Restore FPU context here (if necessary) */\r\n  /* Enable interrupts here */\r\n}\r\n\r\n/*\r\n * The example main function illustrates what is required by your\r\n * application code to initialize, execute, and terminate the generated code.\r\n * Attaching rt_OneStep to a real-time clock is target specific. This example\r\n * illustrates how you do this relative to initializing the model.\r\n */\r\nint_T main(int_T argc, const char *argv[])\r\n{\r\n  /* Unused arguments */\r\n  (void)(argc);\r\n  (void)(argv);\r\n\r\n  /* Initialize model */\r\n  controller_initialize();\r\n\r\n  /* Attach rt_OneStep to a timer or interrupt service routine with\r\n   * period 0.2 seconds (base rate of the model) here.\r\n   * The call syntax for rt_OneStep is\r\n   *\r\n   *  rt_OneStep();\r\n   */\r\n  printf(\"Warning: The simulation will run forever. \"\r\n         \"Generated ERT main won't simulate model step behavior. \"\r\n         \"To change this behavior select the 'MAT-file logging' option.\\n\");\r\n  fflush((NULL));\r\n  while (rtmGetErrorStatus(controller_M) == (NULL)) {\r\n    /*  Perform application tasks here */\r\n  }\r\n\r\n  /* Terminate model */\r\n  controller_terminate();\r\n  return 0;\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"controller.c","type":"source","group":"model","path":"C:\\Users\\Abhishek\\Downloads\\Formula\\git\\vehicle_control_system\\src\\controller_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: controller.c\r\n *\r\n * Code generated for Simulink model 'controller'.\r\n *\r\n * Model version                  : 1.9\r\n * Simulink Coder version         : 9.8 (R2022b) 13-May-2022\r\n * C/C++ source code generated on : Sat Jan 28 16:12:49 2023\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"controller.h\"\r\n#include \"rtwtypes.h\"\r\n#include <math.h>\r\n#include \"controller_types.h\"\r\n#include \"controller_private.h\"\r\n\r\n/* Named constants for Chart: '<S1>/Chart' */\r\n#define IN_ErrorInitializePrechargeStat ((uint8_T)3U)\r\n#define co_IN_ErrorPrechargeClosedState ((uint8_T)4U)\r\n#define con_IN_InitializePrechargeState ((uint8_T)9U)\r\n#define controll_IN_ErrorAllClosedState ((uint8_T)1U)\r\n#define controll_IN_ErrorPrechargeState ((uint8_T)5U)\r\n#define controller_IN_ErrorHVPositive  ((uint8_T)2U)\r\n#define controller_IN_ErrorRunningState ((uint8_T)6U)\r\n#define controller_IN_ErrorStartupState ((uint8_T)7U)\r\n#define controller_IN_InitialState     ((uint8_T)8U)\r\n#define controller_IN_NO_ACTIVE_CHILD  ((uint8_T)0U)\r\n#define controller_IN_PrechargeState   ((uint8_T)10U)\r\n#define controller_IN_RunningState     ((uint8_T)11U)\r\n#define controller_IN_StartupState     ((uint8_T)12U)\r\n#define controller_IN_StartupState1    ((uint8_T)13U)\r\n\r\n/* Named constants for Chart: '<S2>/Chart' */\r\n#define contr_IN_Driver_requested_start ((uint8_T)1U)\r\n#define controlle_IN_Waiting_for_driver ((uint8_T)3U)\r\n#define controller_IN_DI_error         ((uint8_T)1U)\r\n#define controller_IN_DI_running       ((uint8_T)2U)\r\n#define controller_IN_INIT             ((uint8_T)3U)\r\n#define controller_IN_Ready_to_drive   ((uint8_T)2U)\r\n#define controller_IN_SpeakerOff       ((uint8_T)1U)\r\n#define controller_IN_SpeakerOn_       ((uint8_T)2U)\r\n#define controller_IN_Vehicle_coasting ((uint8_T)4U)\r\n\r\n/* Named constants for Chart: '<S3>/Chart' */\r\n#define contro_IN_Command_motor_startup ((uint8_T)1U)\r\n#define contro_IN_DriverInterface_Error ((uint8_T)1U)\r\n#define controlle_IN_Initialize_outputs ((uint8_T)1U)\r\n#define controller_IN_Err_reset        ((uint8_T)2U)\r\n#define controller_IN_HV_run_error     ((uint8_T)1U)\r\n#define controller_IN_HV_startup       ((uint8_T)2U)\r\n#define controller_IN_HV_startup_error ((uint8_T)3U)\r\n#define controller_IN_Motor_faulted    ((uint8_T)4U)\r\n#define controller_IN_Motor_run_error  ((uint8_T)2U)\r\n#define controller_IN_RUNNING          ((uint8_T)2U)\r\n#define controller_IN_RUNNING_ERROR    ((uint8_T)3U)\r\n#define controller_IN_STARTUP          ((uint8_T)4U)\r\n#define controller_IN_STARTUP_ERROR    ((uint8_T)5U)\r\n#define controller_IN_Send_ReadyToDrive ((uint8_T)3U)\r\n\r\n/* Named constants for Chart: '<S4>/RIGHT_MOTOR' */\r\n#define contr_IN_enforceSetpointsZero_p ((uint8_T)1U)\r\n#define contr_IN_motorOff_waitingForGov ((uint8_T)6U)\r\n#define control_IN_enforceSetpointsZero ((uint8_T)2U)\r\n#define controller_IN_AMK_errorDetected ((uint8_T)1U)\r\n#define controller_IN_AMK_errorReset   ((uint8_T)2U)\r\n#define controller_IN_AMK_running      ((uint8_T)3U)\r\n#define controller_IN_AMK_shutdown     ((uint8_T)4U)\r\n#define controller_IN_AMK_startup      ((uint8_T)5U)\r\n#define controller_IN_commandOff       ((uint8_T)1U)\r\n#define controller_IN_commandOn        ((uint8_T)1U)\r\n#define controller_IN_sendReset        ((uint8_T)2U)\r\n#define controller_IN_toggleDCon       ((uint8_T)3U)\r\n#define controller_IN_toggleEnable     ((uint8_T)3U)\r\n#define controller_IN_toggleReset      ((uint8_T)4U)\r\n#define controller_IN_waiting_sysReady ((uint8_T)4U)\r\n\r\n/* Block signals (default storage) */\r\nB_controller_T controller_B;\r\n\r\n/* Block states (default storage) */\r\nDW_controller_T controller_DW;\r\n\r\n/* External inputs (root inport signals with default storage) */\r\nExtU_controller_T controller_U;\r\n\r\n/* External outputs (root outports fed by signals with default storage) */\r\nExtY_controller_T controller_Y;\r\n\r\n/* Real-time model */\r\nstatic RT_MODEL_controller_T controller_M_;\r\nRT_MODEL_controller_T *const controller_M = &controller_M_;\r\nreal32_T look1_iflf_binlxpw(real32_T u0, const real32_T bp0[], const real32_T\r\n  table[], uint32_T maxIndex)\r\n{\r\n  real32_T frac;\r\n  real32_T yL_0d0;\r\n  uint32_T iLeft;\r\n\r\n  /* Column-major Lookup 1-D\r\n     Search method: 'binary'\r\n     Use previous index: 'off'\r\n     Interpolation method: 'Linear point-slope'\r\n     Extrapolation method: 'Linear'\r\n     Use last breakpoint for index at or above upper limit: 'off'\r\n     Remove protection against out-of-range input in generated code: 'off'\r\n   */\r\n  /* Prelookup - Index and Fraction\r\n     Index Search method: 'binary'\r\n     Extrapolation method: 'Linear'\r\n     Use previous index: 'off'\r\n     Use last breakpoint for index at or above upper limit: 'off'\r\n     Remove protection against out-of-range input in generated code: 'off'\r\n   */\r\n  if (u0 <= bp0[0U]) {\r\n    iLeft = 0U;\r\n    frac = (u0 - bp0[0U]) / (bp0[1U] - bp0[0U]);\r\n  } else if (u0 < bp0[maxIndex]) {\r\n    uint32_T bpIdx;\r\n    uint32_T iRght;\r\n\r\n    /* Binary Search */\r\n    bpIdx = maxIndex >> 1U;\r\n    iLeft = 0U;\r\n    iRght = maxIndex;\r\n    while (iRght - iLeft > 1U) {\r\n      if (u0 < bp0[bpIdx]) {\r\n        iRght = bpIdx;\r\n      } else {\r\n        iLeft = bpIdx;\r\n      }\r\n\r\n      bpIdx = (iRght + iLeft) >> 1U;\r\n    }\r\n\r\n    frac = (u0 - bp0[iLeft]) / (bp0[iLeft + 1U] - bp0[iLeft]);\r\n  } else {\r\n    iLeft = maxIndex - 1U;\r\n    frac = (u0 - bp0[maxIndex - 1U]) / (bp0[maxIndex] - bp0[maxIndex - 1U]);\r\n  }\r\n\r\n  /* Column-major Interpolation 1-D\r\n     Interpolation method: 'Linear point-slope'\r\n     Use last breakpoint for index at or above upper limit: 'off'\r\n     Overflow mode: 'portable wrapping'\r\n   */\r\n  yL_0d0 = table[iLeft];\r\n  return (table[iLeft + 1U] - yL_0d0) * frac + yL_0d0;\r\n}\r\n\r\n/* Model step function */\r\nvoid controller_step(void)\r\n{\r\n  real32_T a;\r\n  real32_T rtb_Switch2;\r\n  real32_T rtb_TorqueLimit;\r\n\r\n  /* Chart: '<S3>/Chart' incorporates:\r\n   *  Delay: '<S3>/Delay'\r\n   *  Delay: '<S3>/Delay1'\r\n   *  Delay: '<S3>/Delay2'\r\n   */\r\n  if (controller_DW.is_active_c3_governor_lib == 0U) {\r\n    controller_DW.is_active_c3_governor_lib = 1U;\r\n    controller_DW.is_c3_governor_lib = controlle_IN_Initialize_outputs;\r\n    controller_B.GOV_e_miCmd = CMD_INIT;\r\n    controller_B.GOV_e_diCmd = DI_CMD_INIT;\r\n    controller_DW.motorStartCount = 0U;\r\n  } else {\r\n    switch (controller_DW.is_c3_governor_lib) {\r\n     case controlle_IN_Initialize_outputs:\r\n      controller_B.GOV_e_diCmd = DI_CMD_INIT;\r\n      controller_DW.is_c3_governor_lib = controller_IN_STARTUP;\r\n      controller_DW.is_STARTUP = controller_IN_HV_startup;\r\n      break;\r\n\r\n     case controller_IN_RUNNING:\r\n      if (controller_DW.Delay_DSTATE_f == ERR_STARTUP) {\r\n        controller_DW.is_c3_governor_lib = controller_IN_RUNNING_ERROR;\r\n        controller_DW.is_RUNNING_ERROR = controller_IN_HV_run_error;\r\n        controller_B.GOV_e_diCmd = SYSTEM_ERROR;\r\n      } else if (controller_DW.Delay1_DSTATE == MI_STS_ERROR) {\r\n        controller_DW.is_c3_governor_lib = controller_IN_RUNNING_ERROR;\r\n        controller_DW.is_RUNNING_ERROR = controller_IN_Motor_run_error;\r\n        controller_B.GOV_e_diCmd = SYSTEM_ERROR;\r\n      }\r\n      break;\r\n\r\n     case controller_IN_RUNNING_ERROR:\r\n      if (controller_DW.is_RUNNING_ERROR == controller_IN_HV_run_error) {\r\n        controller_B.GOV_e_diCmd = SYSTEM_ERROR;\r\n      } else {\r\n        /* case IN_Motor_run_error: */\r\n        controller_B.GOV_e_diCmd = SYSTEM_ERROR;\r\n      }\r\n      break;\r\n\r\n     case controller_IN_STARTUP:\r\n      {\r\n        if (controller_DW.Delay_DSTATE_f == ERR_STARTUP) {\r\n          controller_DW.is_STARTUP = controller_IN_NO_ACTIVE_CHILD;\r\n          controller_DW.is_c3_governor_lib = controller_IN_STARTUP_ERROR;\r\n          controller_DW.is_STARTUP_ERROR = controller_IN_HV_startup_error;\r\n        } else if (controller_DW.Delay2_DSTATE == DI_ERROR) {\r\n          controller_DW.is_STARTUP = controller_IN_NO_ACTIVE_CHILD;\r\n          controller_DW.is_c3_governor_lib = controller_IN_STARTUP_ERROR;\r\n          controller_DW.is_STARTUP_ERROR = contro_IN_DriverInterface_Error;\r\n        } else if (controller_DW.Delay1_DSTATE == MI_STS_ERROR) {\r\n          if (controller_DW.motorStartCount >= 5) {\r\n            controller_DW.is_STARTUP = controller_IN_NO_ACTIVE_CHILD;\r\n            controller_DW.is_c3_governor_lib = controller_IN_STARTUP_ERROR;\r\n            controller_DW.is_STARTUP_ERROR = controller_IN_Motor_faulted;\r\n            controller_B.GOV_e_miCmd = CMD_SHUTDOWN;\r\n          } else {\r\n            controller_DW.is_STARTUP = controller_IN_NO_ACTIVE_CHILD;\r\n            controller_DW.is_c3_governor_lib = controller_IN_STARTUP_ERROR;\r\n            controller_DW.is_STARTUP_ERROR = controller_IN_Err_reset;\r\n          }\r\n        } else {\r\n          switch (controller_DW.is_STARTUP) {\r\n           case contro_IN_Command_motor_startup:\r\n            if ((controller_DW.Delay1_DSTATE == RUNNING) &&\r\n                (controller_DW.Delay2_DSTATE == DRV_START_REQ)) {\r\n              controller_DW.is_STARTUP = controller_IN_Send_ReadyToDrive;\r\n              controller_B.GOV_e_diCmd = READY_TO_DRIVE;\r\n            }\r\n            break;\r\n\r\n           case controller_IN_HV_startup:\r\n            {\r\n              if (controller_DW.Delay_DSTATE_f == BM_RUNNING) {\r\n                uint32_T tmp;\r\n                controller_DW.is_STARTUP = contro_IN_Command_motor_startup;\r\n                controller_B.GOV_e_miCmd = CMD_STARTUP;\r\n                tmp = controller_DW.motorStartCount + 1U;\r\n                if (controller_DW.motorStartCount + 1U > 65535U) {\r\n                  tmp = 65535U;\r\n                }\r\n\r\n                controller_DW.motorStartCount = (uint16_T)tmp;\r\n              }\r\n            }\r\n            break;\r\n\r\n           default:\r\n            /* case IN_Send_ReadyToDrive: */\r\n            controller_B.GOV_e_diCmd = READY_TO_DRIVE;\r\n            if (controller_DW.Delay2_DSTATE == DI_RUNNING) {\r\n              controller_DW.is_STARTUP = controller_IN_NO_ACTIVE_CHILD;\r\n              controller_DW.is_c3_governor_lib = controller_IN_RUNNING;\r\n            }\r\n            break;\r\n          }\r\n        }\r\n      }\r\n      break;\r\n\r\n     default:\r\n      /* case IN_STARTUP_ERROR: */\r\n      switch (controller_DW.is_STARTUP_ERROR) {\r\n       case contro_IN_DriverInterface_Error:\r\n       case controller_IN_HV_startup_error:\r\n        break;\r\n\r\n       case controller_IN_Err_reset:\r\n        if (controller_DW.Delay1_DSTATE == OFF) {\r\n          controller_DW.is_STARTUP_ERROR = controller_IN_NO_ACTIVE_CHILD;\r\n          controller_DW.is_c3_governor_lib = controller_IN_STARTUP;\r\n          controller_DW.is_STARTUP = controller_IN_HV_startup;\r\n        } else {\r\n          controller_B.GOV_e_miCmd = ERR_RESET;\r\n        }\r\n        break;\r\n\r\n       default:\r\n        /* case IN_Motor_faulted: */\r\n        break;\r\n      }\r\n      break;\r\n    }\r\n  }\r\n\r\n  /* End of Chart: '<S3>/Chart' */\r\n\r\n  /* Chart: '<S2>/Chart' incorporates:\r\n   *  Delay: '<S3>/Delay2'\r\n   *  Inport: '<Root>/DI_b_DriverButton'\r\n   */\r\n  if (controller_DW.temporalCounter_i1_a < 15U) {\r\n    controller_DW.temporalCounter_i1_a++;\r\n  }\r\n\r\n  if (controller_DW.is_active_c3_driver_interface_l == 0U) {\r\n    controller_DW.is_active_c3_driver_interface_l = 1U;\r\n    controller_DW.is_c3_driver_interface_lib = controller_IN_INIT;\r\n    controller_DW.Delay2_DSTATE = DI_STS_INIT;\r\n    controller_B.b_ReadyToDrive = false;\r\n\r\n    /* Outport: '<Root>/DI_b_driverSpeaker' incorporates:\r\n     *  Delay: '<S3>/Delay2'\r\n     */\r\n    controller_Y.DI_b_driverSpeaker = false;\r\n  } else {\r\n    switch (controller_DW.is_c3_driver_interface_lib) {\r\n     case controller_IN_DI_error:\r\n      controller_DW.Delay2_DSTATE = DI_ERROR;\r\n      break;\r\n\r\n     case controller_IN_DI_running:\r\n      switch (controller_DW.is_DI_running) {\r\n       case contr_IN_Driver_requested_start:\r\n        controller_DW.Delay2_DSTATE = DRV_START_REQ;\r\n        if (controller_B.GOV_e_diCmd == READY_TO_DRIVE) {\r\n          controller_DW.is_DI_running = controller_IN_Ready_to_drive;\r\n          controller_B.b_ReadyToDrive = true;\r\n          controller_DW.Delay2_DSTATE = DI_RUNNING;\r\n          controller_DW.is_Ready_to_drive = controller_IN_SpeakerOn_;\r\n          controller_DW.temporalCounter_i1_a = 0U;\r\n\r\n          /* Outport: '<Root>/DI_b_driverSpeaker' */\r\n          controller_Y.DI_b_driverSpeaker = true;\r\n        }\r\n        break;\r\n\r\n       case controller_IN_Ready_to_drive:\r\n        controller_B.b_ReadyToDrive = true;\r\n        controller_DW.Delay2_DSTATE = DI_RUNNING;\r\n        if (controller_B.GOV_e_diCmd == SYSTEM_ERROR) {\r\n          controller_DW.is_Ready_to_drive = controller_IN_NO_ACTIVE_CHILD;\r\n          controller_DW.is_DI_running = controller_IN_NO_ACTIVE_CHILD;\r\n          controller_DW.is_c3_driver_interface_lib =\r\n            controller_IN_Vehicle_coasting;\r\n          controller_B.b_ReadyToDrive = false;\r\n          controller_DW.Delay2_DSTATE = DI_IDLE;\r\n        } else if (controller_DW.is_Ready_to_drive == controller_IN_SpeakerOff)\r\n        {\r\n          /* Outport: '<Root>/DI_b_driverSpeaker' */\r\n          controller_Y.DI_b_driverSpeaker = false;\r\n        } else {\r\n          /* Outport: '<Root>/DI_b_driverSpeaker' */\r\n          /* case IN_SpeakerOn_: */\r\n          controller_Y.DI_b_driverSpeaker = true;\r\n          if (controller_DW.temporalCounter_i1_a >= 10U) {\r\n            controller_DW.is_Ready_to_drive = controller_IN_SpeakerOff;\r\n\r\n            /* Outport: '<Root>/DI_b_driverSpeaker' */\r\n            controller_Y.DI_b_driverSpeaker = false;\r\n          }\r\n        }\r\n        break;\r\n\r\n       default:\r\n        /* case IN_Waiting_for_driver: */\r\n        controller_DW.Delay2_DSTATE = WAITING_FOR_DRVR;\r\n        if (controller_U.DI_b_DriverButton == 1.0) {\r\n          controller_DW.is_DI_running = contr_IN_Driver_requested_start;\r\n          controller_DW.Delay2_DSTATE = DRV_START_REQ;\r\n        }\r\n        break;\r\n      }\r\n      break;\r\n\r\n     case controller_IN_INIT:\r\n      controller_B.b_ReadyToDrive = false;\r\n\r\n      /* Outport: '<Root>/DI_b_driverSpeaker' */\r\n      controller_Y.DI_b_driverSpeaker = false;\r\n      controller_DW.is_c3_driver_interface_lib = controller_IN_DI_running;\r\n      controller_DW.is_DI_running = controlle_IN_Waiting_for_driver;\r\n      controller_DW.Delay2_DSTATE = WAITING_FOR_DRVR;\r\n      break;\r\n\r\n     default:\r\n      /* case IN_Vehicle_coasting: */\r\n      controller_B.b_ReadyToDrive = false;\r\n      controller_DW.Delay2_DSTATE = DI_IDLE;\r\n      break;\r\n    }\r\n  }\r\n\r\n  /* End of Chart: '<S2>/Chart' */\r\n\r\n  /* Switch: '<S2>/Switch2' incorporates:\r\n   *  Constant: '<S13>/LowerPotentiometerLimit1'\r\n   *  Constant: '<S13>/UpperPotentiometerLimit1'\r\n   *  Constant: '<S2>/Constant1'\r\n   *  Gain: '<S13>/Gain'\r\n   *  Inport: '<Root>/DI_V_BrakePedalPos'\r\n   *  Logic: '<S19>/FixPt Logical Operator'\r\n   *  Product: '<S20>/Divide'\r\n   *  RelationalOperator: '<S19>/Lower Test'\r\n   *  RelationalOperator: '<S19>/Upper Test'\r\n   *  Sum: '<S20>/Subtract'\r\n   */\r\n  if ((controller_U.DI_V_BrakePedalPos >= 0.0F) &&\r\n      (controller_U.DI_V_BrakePedalPos <= 1024.0F)) {\r\n    rtb_Switch2 = 0.0F;\r\n  } else {\r\n    rtb_Switch2 = (controller_U.DI_V_BrakePedalPos - 1024.0F) / 1024.0F * 100.0F;\r\n  }\r\n\r\n  /* End of Switch: '<S2>/Switch2' */\r\n\r\n  /* MATLAB Function: '<S5>/RIGHT_LIMIT' incorporates:\r\n   *  Constant: '<S5>/MaxMotorCurrent'\r\n   *  Constant: '<S5>/MaxMotorTorque'\r\n   *  Constant: '<S5>/Vbat'\r\n   *  Gain: '<S5>/Gain'\r\n   *  Gain: '<S5>/convertToAmps3'\r\n   *  Inport: '<Root>/AMK_ActualVelocity'\r\n   *  Inport: '<Root>/AMK_MagnetizingCurrent'\r\n   */\r\n  rtb_TorqueLimit = fmaxf(0.0999984741F * (real32_T)\r\n    controller_U.AMK_MagnetizingCurrent, 0.0F);\r\n  a = fminf(controller_ConstB.Gain1, 52.0F);\r\n  rtb_TorqueLimit = fminf(fmaxf(fmaxf(sqrtf(a * a - rtb_TorqueLimit *\r\n    rtb_TorqueLimit), 0.0F) * 600.0F / ((real32_T)\r\n    controller_U.AMK_ActualVelocity * 3.14159274F / 30.0F), 0.0F), 27.0F);\r\n\r\n  /* Switch: '<S5>/Switch' incorporates:\r\n   *  Constant: '<S12>/LowerPotentiometerLimit1'\r\n   *  Constant: '<S12>/UpperPotentiometerLimit1'\r\n   *  Constant: '<S5>/Constant6'\r\n   *  If: '<S2>/If'\r\n   *  Inport: '<Root>/DI_V_AccelPedalPos2'\r\n   *  Logic: '<S17>/FixPt Logical Operator'\r\n   *  Logic: '<S2>/NOT'\r\n   *  Lookup_n-D: '<S2>/AccelPedalPos1 LUT'\r\n   *  MinMax: '<S5>/Min'\r\n   *  Product: '<S5>/Divide'\r\n   *  RelationalOperator: '<S17>/Lower Test'\r\n   *  RelationalOperator: '<S17>/Upper Test'\r\n   */\r\n  if (rtb_Switch2 > 0.0F) {\r\n    rtb_Switch2 = 0.0F;\r\n  } else {\r\n    if (!controller_B.b_ReadyToDrive) {\r\n      /* Outputs for IfAction SubSystem: '<S2>/If Action Subsystem' incorporates:\r\n       *  ActionPort: '<S8>/Action Port'\r\n       */\r\n      /* If: '<S2>/If' incorporates:\r\n       *  Constant: '<S2>/Constant'\r\n       *  SignalConversion generated from: '<S8>/In1'\r\n       */\r\n      rtb_Switch2 = 0.0F;\r\n\r\n      /* End of Outputs for SubSystem: '<S2>/If Action Subsystem' */\r\n    } else if ((controller_U.DI_V_AccelPedalPos2 >= 0.0F) &&\r\n               (controller_U.DI_V_AccelPedalPos2 <= 1024.0F)) {\r\n      /* If: '<S2>/If' incorporates:\r\n       *  Constant: '<S12>/UpperPotentiometerLimit1'\r\n       *  Gain: '<S12>/Gain'\r\n       *  Inport: '<Root>/DI_V_AccelPedalPos2'\r\n       *  Product: '<S18>/Divide'\r\n       *  Sum: '<S18>/Subtract'\r\n       */\r\n      rtb_Switch2 = (controller_U.DI_V_AccelPedalPos2 - 1024.0F) / 1024.0F *\r\n        100.0F;\r\n    } else {\r\n      /* If: '<S2>/If' incorporates:\r\n       *  Constant: '<S11>/UpperPotentiometerLimit1'\r\n       *  Gain: '<S11>/Gain'\r\n       *  Inport: '<Root>/DI_V_AccelPedalPos1'\r\n       *  Product: '<S16>/Divide'\r\n       *  Sum: '<S16>/Subtract'\r\n       */\r\n      rtb_Switch2 = (controller_U.DI_V_AccelPedalPos1 - 1024.0F) / 1024.0F *\r\n        100.0F;\r\n    }\r\n\r\n    rtb_Switch2 = look1_iflf_binlxpw(rtb_Switch2, controller_ConstP.pooled3,\r\n      controller_ConstP.pooled3, 20U) * fminf(rtb_TorqueLimit, rtb_TorqueLimit);\r\n  }\r\n\r\n  /* End of Switch: '<S5>/Switch' */\r\n\r\n  /* Chart: '<S4>/RIGHT_MOTOR' incorporates:\r\n   *  Constant: '<S5>/NegTorqueLimit'\r\n   *  Inport: '<Root>/AMK_bDcOn'\r\n   *  Inport: '<Root>/AMK_bError'\r\n   *  Inport: '<Root>/AMK_bInverterOn'\r\n   *  Inport: '<Root>/AMK_bQuitDcOn'\r\n   *  Inport: '<Root>/AMK_bQuitInverterOn'\r\n   *  Inport: '<Root>/AMK_bSystemReady'\r\n   */\r\n  if (controller_DW.temporalCounter_i1 < 7U) {\r\n    controller_DW.temporalCounter_i1++;\r\n  }\r\n\r\n  if (controller_DW.is_active_c3_motor_interface_li == 0U) {\r\n    controller_DW.is_active_c3_motor_interface_li = 1U;\r\n    controller_DW.is_c3_motor_interface_lib = contr_IN_motorOff_waitingForGov;\r\n    controller_B.MI_motorStatus = OFF;\r\n\r\n    /* Outport: '<Root>/AMK_bInverterOn_tx' */\r\n    controller_Y.AMK_bInverterOn_tx = 0U;\r\n\r\n    /* Outport: '<Root>/AMK_bDcOn_tx' */\r\n    controller_Y.AMK_bDcOn_tx = 0U;\r\n\r\n    /* Outport: '<Root>/AMK_bEnable' */\r\n    controller_Y.AMK_bEnable = 0U;\r\n\r\n    /* Outport: '<Root>/AMK_bErrorReset' */\r\n    controller_Y.AMK_bErrorReset = 0U;\r\n\r\n    /* Outport: '<Root>/AMK_TargetVelocity' */\r\n    controller_Y.AMK_TargetVelocity = 0.0F;\r\n    controller_B.AMK_TorqueLimitPositiv = 0.0F;\r\n    controller_B.AMK_TorqueLimitNegativ = 0.0F;\r\n  } else {\r\n    switch (controller_DW.is_c3_motor_interface_lib) {\r\n     case controller_IN_AMK_errorDetected:\r\n      if (controller_B.GOV_e_miCmd == ERR_RESET) {\r\n        controller_DW.is_c3_motor_interface_lib = controller_IN_AMK_errorReset;\r\n        controller_DW.is_AMK_errorReset = contr_IN_enforceSetpointsZero_p;\r\n\r\n        /* Outport: '<Root>/AMK_TargetVelocity' */\r\n        controller_Y.AMK_TargetVelocity = 0.0F;\r\n        controller_B.AMK_TorqueLimitPositiv = 0.0F;\r\n        controller_B.AMK_TorqueLimitNegativ = 0.0F;\r\n\r\n        /* Outport: '<Root>/AMK_bInverterOn_tx' */\r\n        controller_Y.AMK_bInverterOn_tx = 0U;\r\n      }\r\n      break;\r\n\r\n     case controller_IN_AMK_errorReset:\r\n      switch (controller_DW.is_AMK_errorReset) {\r\n       case contr_IN_enforceSetpointsZero_p:\r\n        /* Outport: '<Root>/AMK_bInverterOn_tx' */\r\n        controller_Y.AMK_bInverterOn_tx = 0U;\r\n        if (!controller_U.AMK_bInverterOn) {\r\n          controller_DW.is_AMK_errorReset = controller_IN_toggleEnable;\r\n          controller_DW.temporalCounter_i1 = 0U;\r\n\r\n          /* Outport: '<Root>/AMK_bEnable' */\r\n          controller_Y.AMK_bEnable = 0U;\r\n        }\r\n        break;\r\n\r\n       case controller_IN_sendReset:\r\n        /* Outport: '<Root>/AMK_bErrorReset' */\r\n        controller_Y.AMK_bErrorReset = 1U;\r\n        if (controller_DW.temporalCounter_i1 >= 3U) {\r\n          controller_DW.is_AMK_errorReset = controller_IN_toggleReset;\r\n\r\n          /* Outport: '<Root>/AMK_bErrorReset' */\r\n          controller_Y.AMK_bErrorReset = 0U;\r\n        }\r\n        break;\r\n\r\n       case controller_IN_toggleEnable:\r\n        /* Outport: '<Root>/AMK_bEnable' */\r\n        controller_Y.AMK_bEnable = 0U;\r\n        if (controller_DW.temporalCounter_i1 >= 3U) {\r\n          controller_DW.is_AMK_errorReset = controller_IN_sendReset;\r\n          controller_DW.temporalCounter_i1 = 0U;\r\n\r\n          /* Outport: '<Root>/AMK_bErrorReset' */\r\n          controller_Y.AMK_bErrorReset = 1U;\r\n        }\r\n        break;\r\n\r\n       default:\r\n        /* Outport: '<Root>/AMK_bErrorReset' */\r\n        /* case IN_toggleReset: */\r\n        controller_Y.AMK_bErrorReset = 0U;\r\n        if (controller_U.AMK_bSystemReady) {\r\n          controller_DW.is_AMK_errorReset = controller_IN_NO_ACTIVE_CHILD;\r\n          controller_DW.is_c3_motor_interface_lib =\r\n            contr_IN_motorOff_waitingForGov;\r\n          controller_B.MI_motorStatus = OFF;\r\n\r\n          /* Outport: '<Root>/AMK_bInverterOn_tx' */\r\n          controller_Y.AMK_bInverterOn_tx = 0U;\r\n\r\n          /* Outport: '<Root>/AMK_bDcOn_tx' */\r\n          controller_Y.AMK_bDcOn_tx = 0U;\r\n\r\n          /* Outport: '<Root>/AMK_bEnable' */\r\n          controller_Y.AMK_bEnable = 0U;\r\n\r\n          /* Outport: '<Root>/AMK_TargetVelocity' */\r\n          controller_Y.AMK_TargetVelocity = 0.0F;\r\n          controller_B.AMK_TorqueLimitPositiv = 0.0F;\r\n          controller_B.AMK_TorqueLimitNegativ = 0.0F;\r\n        }\r\n        break;\r\n      }\r\n      break;\r\n\r\n     case controller_IN_AMK_running:\r\n      if (controller_U.AMK_bError) {\r\n        controller_DW.is_c3_motor_interface_lib =\r\n          controller_IN_AMK_errorDetected;\r\n        controller_B.MI_motorStatus = MI_STS_ERROR;\r\n      } else if (controller_B.GOV_e_miCmd == CMD_SHUTDOWN) {\r\n        controller_DW.is_c3_motor_interface_lib = controller_IN_AMK_shutdown;\r\n        controller_DW.is_AMK_shutdown = control_IN_enforceSetpointsZero;\r\n        controller_B.MI_motorStatus = SHUTDOWN;\r\n\r\n        /* Outport: '<Root>/AMK_TargetVelocity' */\r\n        controller_Y.AMK_TargetVelocity = 0.0F;\r\n        controller_B.AMK_TorqueLimitPositiv = 0.0F;\r\n        controller_B.AMK_TorqueLimitNegativ = 0.0F;\r\n\r\n        /* Outport: '<Root>/AMK_bInverterOn_tx' */\r\n        controller_Y.AMK_bInverterOn_tx = 0U;\r\n      } else {\r\n        controller_B.MI_motorStatus = RUNNING;\r\n\r\n        /* Outport: '<Root>/AMK_TargetVelocity' incorporates:\r\n         *  Constant: '<S5>/MaxAMKspeed'\r\n         */\r\n        controller_Y.AMK_TargetVelocity = 20000.0F;\r\n        controller_B.AMK_TorqueLimitPositiv = rtb_Switch2;\r\n        controller_B.AMK_TorqueLimitNegativ = 0.0F;\r\n      }\r\n      break;\r\n\r\n     case controller_IN_AMK_shutdown:\r\n      switch (controller_DW.is_AMK_shutdown) {\r\n       case controller_IN_commandOff:\r\n        /* Outport: '<Root>/AMK_bEnable' */\r\n        controller_Y.AMK_bEnable = 0U;\r\n        if (!controller_U.AMK_bQuitDcOn) {\r\n          controller_DW.is_AMK_shutdown = controller_IN_toggleDCon;\r\n\r\n          /* Outport: '<Root>/AMK_bDcOn_tx' */\r\n          controller_Y.AMK_bDcOn_tx = 0U;\r\n        } else if (controller_U.AMK_bError) {\r\n          controller_DW.is_AMK_shutdown = controller_IN_NO_ACTIVE_CHILD;\r\n          controller_DW.is_c3_motor_interface_lib =\r\n            controller_IN_AMK_errorDetected;\r\n          controller_B.MI_motorStatus = MI_STS_ERROR;\r\n        }\r\n        break;\r\n\r\n       case control_IN_enforceSetpointsZero:\r\n        /* Outport: '<Root>/AMK_bInverterOn_tx' */\r\n        controller_Y.AMK_bInverterOn_tx = 0U;\r\n        if (!controller_U.AMK_bInverterOn) {\r\n          controller_DW.is_AMK_shutdown = controller_IN_commandOff;\r\n\r\n          /* Outport: '<Root>/AMK_bEnable' */\r\n          controller_Y.AMK_bEnable = 0U;\r\n        } else if (controller_U.AMK_bError) {\r\n          controller_DW.is_AMK_shutdown = controller_IN_NO_ACTIVE_CHILD;\r\n          controller_DW.is_c3_motor_interface_lib =\r\n            controller_IN_AMK_errorDetected;\r\n          controller_B.MI_motorStatus = MI_STS_ERROR;\r\n        }\r\n        break;\r\n\r\n       default:\r\n        /* Outport: '<Root>/AMK_bDcOn_tx' */\r\n        /* case IN_toggleDCon: */\r\n        controller_Y.AMK_bDcOn_tx = 0U;\r\n        if ((!controller_U.AMK_bDcOn) && (!controller_U.AMK_bQuitDcOn)) {\r\n          controller_DW.is_AMK_shutdown = controller_IN_NO_ACTIVE_CHILD;\r\n          controller_DW.is_c3_motor_interface_lib =\r\n            contr_IN_motorOff_waitingForGov;\r\n          controller_B.MI_motorStatus = OFF;\r\n\r\n          /* Outport: '<Root>/AMK_bInverterOn_tx' */\r\n          controller_Y.AMK_bInverterOn_tx = 0U;\r\n\r\n          /* Outport: '<Root>/AMK_bEnable' */\r\n          controller_Y.AMK_bEnable = 0U;\r\n\r\n          /* Outport: '<Root>/AMK_bErrorReset' */\r\n          controller_Y.AMK_bErrorReset = 0U;\r\n\r\n          /* Outport: '<Root>/AMK_TargetVelocity' */\r\n          controller_Y.AMK_TargetVelocity = 0.0F;\r\n          controller_B.AMK_TorqueLimitPositiv = 0.0F;\r\n          controller_B.AMK_TorqueLimitNegativ = 0.0F;\r\n        } else if (controller_U.AMK_bError) {\r\n          controller_DW.is_AMK_shutdown = controller_IN_NO_ACTIVE_CHILD;\r\n          controller_DW.is_c3_motor_interface_lib =\r\n            controller_IN_AMK_errorDetected;\r\n          controller_B.MI_motorStatus = MI_STS_ERROR;\r\n        }\r\n        break;\r\n      }\r\n      break;\r\n\r\n     case controller_IN_AMK_startup:\r\n      switch (controller_DW.is_AMK_startup) {\r\n       case controller_IN_commandOn:\r\n        /* Outport: '<Root>/AMK_bEnable' */\r\n        controller_Y.AMK_bEnable = 1U;\r\n\r\n        /* Outport: '<Root>/AMK_bInverterOn_tx' */\r\n        controller_Y.AMK_bInverterOn_tx = 1U;\r\n        if (controller_U.AMK_bInverterOn && controller_U.AMK_bQuitInverterOn) {\r\n          controller_DW.is_AMK_startup = controller_IN_NO_ACTIVE_CHILD;\r\n          controller_DW.is_c3_motor_interface_lib = controller_IN_AMK_running;\r\n        } else if (controller_U.AMK_bError) {\r\n          controller_DW.is_AMK_startup = controller_IN_NO_ACTIVE_CHILD;\r\n          controller_DW.is_c3_motor_interface_lib =\r\n            controller_IN_AMK_errorDetected;\r\n          controller_B.MI_motorStatus = MI_STS_ERROR;\r\n        }\r\n        break;\r\n\r\n       case control_IN_enforceSetpointsZero:\r\n        if (controller_DW.temporalCounter_i1 >= 5U) {\r\n          controller_DW.is_AMK_startup = controller_IN_commandOn;\r\n\r\n          /* Outport: '<Root>/AMK_bEnable' */\r\n          controller_Y.AMK_bEnable = 1U;\r\n\r\n          /* Outport: '<Root>/AMK_bInverterOn_tx' */\r\n          controller_Y.AMK_bInverterOn_tx = 1U;\r\n        } else if (controller_U.AMK_bError) {\r\n          controller_DW.is_AMK_startup = controller_IN_NO_ACTIVE_CHILD;\r\n          controller_DW.is_c3_motor_interface_lib =\r\n            controller_IN_AMK_errorDetected;\r\n          controller_B.MI_motorStatus = MI_STS_ERROR;\r\n        }\r\n        break;\r\n\r\n       case controller_IN_toggleDCon:\r\n        /* Outport: '<Root>/AMK_bDcOn_tx' */\r\n        controller_Y.AMK_bDcOn_tx = 1U;\r\n        if (controller_U.AMK_bDcOn && controller_U.AMK_bQuitDcOn) {\r\n          controller_DW.is_AMK_startup = control_IN_enforceSetpointsZero;\r\n          controller_DW.temporalCounter_i1 = 0U;\r\n\r\n          /* Outport: '<Root>/AMK_TargetVelocity' */\r\n          controller_Y.AMK_TargetVelocity = 0.0F;\r\n          controller_B.AMK_TorqueLimitPositiv = 0.0F;\r\n          controller_B.AMK_TorqueLimitNegativ = 0.0F;\r\n        } else if (controller_U.AMK_bError) {\r\n          controller_DW.is_AMK_startup = controller_IN_NO_ACTIVE_CHILD;\r\n          controller_DW.is_c3_motor_interface_lib =\r\n            controller_IN_AMK_errorDetected;\r\n          controller_B.MI_motorStatus = MI_STS_ERROR;\r\n        }\r\n        break;\r\n\r\n       default:\r\n        /* case IN_waiting_sysReady: */\r\n        if (controller_U.AMK_bSystemReady) {\r\n          controller_DW.is_AMK_startup = controller_IN_toggleDCon;\r\n\r\n          /* Outport: '<Root>/AMK_bDcOn_tx' */\r\n          controller_Y.AMK_bDcOn_tx = 1U;\r\n        } else if (controller_U.AMK_bError) {\r\n          controller_DW.is_AMK_startup = controller_IN_NO_ACTIVE_CHILD;\r\n          controller_DW.is_c3_motor_interface_lib =\r\n            controller_IN_AMK_errorDetected;\r\n          controller_B.MI_motorStatus = MI_STS_ERROR;\r\n        }\r\n        break;\r\n      }\r\n      break;\r\n\r\n     default:\r\n      /* Outport: '<Root>/AMK_bInverterOn_tx' */\r\n      /* case IN_motorOff_waitingForGov: */\r\n      controller_Y.AMK_bInverterOn_tx = 0U;\r\n\r\n      /* Outport: '<Root>/AMK_bDcOn_tx' */\r\n      controller_Y.AMK_bDcOn_tx = 0U;\r\n\r\n      /* Outport: '<Root>/AMK_bEnable' */\r\n      controller_Y.AMK_bEnable = 0U;\r\n\r\n      /* Outport: '<Root>/AMK_bErrorReset' */\r\n      controller_Y.AMK_bErrorReset = 0U;\r\n      if (controller_B.GOV_e_miCmd == CMD_STARTUP) {\r\n        controller_DW.is_c3_motor_interface_lib = controller_IN_AMK_startup;\r\n        controller_DW.is_AMK_startup = controller_IN_waiting_sysReady;\r\n        controller_B.MI_motorStatus = STARTUP;\r\n      }\r\n      break;\r\n    }\r\n  }\r\n\r\n  /* End of Chart: '<S4>/RIGHT_MOTOR' */\r\n\r\n  /* Outport: '<Root>/AMK_TorqueLimitPositiv' incorporates:\r\n   *  Gain: '<S4>/Gain'\r\n   */\r\n  controller_Y.AMK_TorqueLimitPositiv = 1000.0F *\r\n    controller_B.AMK_TorqueLimitPositiv;\r\n\r\n  /* Outport: '<Root>/AMK_TorqueLimitNegativ' incorporates:\r\n   *  Gain: '<S4>/Gain1'\r\n   */\r\n  controller_Y.AMK_TorqueLimitNegativ = 1000.0F *\r\n    controller_B.AMK_TorqueLimitNegativ;\r\n\r\n  /* Chart: '<S1>/Chart' incorporates:\r\n   *  Delay: '<S3>/Delay'\r\n   *  Inport: '<Root>/BM_b_HVnegContactorSts'\r\n   *  Inport: '<Root>/BM_b_HVposContactorSts'\r\n   *  Inport: '<Root>/BM_b_prechrgContactorSts'\r\n   */\r\n  if (controller_DW.temporalCounter_i1_p < 7U) {\r\n    controller_DW.temporalCounter_i1_p++;\r\n  }\r\n\r\n  if (controller_DW.is_active_c3_battery_monitor_li == 0U) {\r\n    controller_DW.is_active_c3_battery_monitor_li = 1U;\r\n    controller_DW.is_c3_battery_monitor_lib = controller_IN_InitialState;\r\n    controller_DW.Delay_DSTATE_f = BM_INIT;\r\n  } else {\r\n    switch (controller_DW.is_c3_battery_monitor_lib) {\r\n     case controll_IN_ErrorAllClosedState:\r\n      controller_DW.Delay_DSTATE_f = ERR_ALL_CLOSED;\r\n      break;\r\n\r\n     case controller_IN_ErrorHVPositive:\r\n      controller_DW.Delay_DSTATE_f = ERR_HV_POSITIVE;\r\n      break;\r\n\r\n     case IN_ErrorInitializePrechargeStat:\r\n      controller_DW.Delay_DSTATE_f = ERR_INIT_PRECHARGE;\r\n      break;\r\n\r\n     case co_IN_ErrorPrechargeClosedState:\r\n      controller_DW.Delay_DSTATE_f = ERR_PRECHARGE_CLOSED;\r\n      break;\r\n\r\n     case controll_IN_ErrorPrechargeState:\r\n      controller_DW.Delay_DSTATE_f = ERR_PRECHARGE;\r\n      break;\r\n\r\n     case controller_IN_ErrorRunningState:\r\n      controller_DW.Delay_DSTATE_f = ERR_RUNNING;\r\n      break;\r\n\r\n     case controller_IN_ErrorStartupState:\r\n      controller_DW.Delay_DSTATE_f = ERR_STARTUP;\r\n      break;\r\n\r\n     case controller_IN_InitialState:\r\n      controller_DW.Delay_DSTATE_f = BM_INIT;\r\n      if ((controller_U.BM_b_prechrgContactorSts == 0.0) &&\r\n          (controller_U.BM_b_HVnegContactorSts == 0.0) &&\r\n          (controller_U.BM_b_HVposContactorSts == 0.0)) {\r\n        controller_DW.is_c3_battery_monitor_lib = controller_IN_StartupState1;\r\n        controller_DW.Delay_DSTATE_f = BM_IDLE;\r\n      } else if ((controller_U.BM_b_prechrgContactorSts == 1.0) &&\r\n                 (controller_U.BM_b_HVnegContactorSts == 0.0) &&\r\n                 (controller_U.BM_b_HVposContactorSts == 0.0)) {\r\n        controller_DW.is_c3_battery_monitor_lib =\r\n          co_IN_ErrorPrechargeClosedState;\r\n        controller_DW.Delay_DSTATE_f = ERR_PRECHARGE_CLOSED;\r\n      } else if ((controller_U.BM_b_prechrgContactorSts == 1.0) &&\r\n                 (controller_U.BM_b_HVnegContactorSts == 1.0) &&\r\n                 (controller_U.BM_b_HVposContactorSts == 1.0)) {\r\n        controller_DW.is_c3_battery_monitor_lib =\r\n          controll_IN_ErrorAllClosedState;\r\n        controller_DW.Delay_DSTATE_f = ERR_ALL_CLOSED;\r\n      } else if ((controller_U.BM_b_prechrgContactorSts == 0.0) &&\r\n                 (controller_U.BM_b_HVnegContactorSts == 0.0) &&\r\n                 (controller_U.BM_b_HVposContactorSts == 1.0)) {\r\n        controller_DW.is_c3_battery_monitor_lib = controller_IN_ErrorHVPositive;\r\n        controller_DW.Delay_DSTATE_f = ERR_HV_POSITIVE;\r\n      } else if ((controller_U.BM_b_prechrgContactorSts == 1.0) &&\r\n                 (controller_U.BM_b_HVnegContactorSts == 1.0) &&\r\n                 (controller_U.BM_b_HVposContactorSts == 0.0)) {\r\n        controller_DW.is_c3_battery_monitor_lib = controller_IN_PrechargeState;\r\n        controller_DW.temporalCounter_i1_p = 0U;\r\n        controller_DW.Delay_DSTATE_f = PRECHARGE;\r\n      } else if ((controller_U.BM_b_prechrgContactorSts == 0.0) &&\r\n                 (controller_U.BM_b_HVnegContactorSts == 1.0) &&\r\n                 (controller_U.BM_b_HVposContactorSts == 1.0)) {\r\n        controller_DW.is_c3_battery_monitor_lib = controller_IN_RunningState;\r\n        controller_DW.temporalCounter_i1_p = 0U;\r\n        controller_DW.Delay_DSTATE_f = BM_RUNNING;\r\n      }\r\n      break;\r\n\r\n     case con_IN_InitializePrechargeState:\r\n      controller_DW.Delay_DSTATE_f = INIT_PRECHARGE;\r\n      if ((controller_U.BM_b_prechrgContactorSts == 1.0) &&\r\n          (controller_U.BM_b_HVnegContactorSts == 1.0) &&\r\n          (controller_U.BM_b_HVposContactorSts == 1.0)) {\r\n        controller_DW.is_c3_battery_monitor_lib = controller_IN_PrechargeState;\r\n        controller_DW.temporalCounter_i1_p = 0U;\r\n        controller_DW.Delay_DSTATE_f = PRECHARGE;\r\n      } else if (controller_DW.temporalCounter_i1_p >= 5U) {\r\n        controller_DW.is_c3_battery_monitor_lib =\r\n          IN_ErrorInitializePrechargeStat;\r\n        controller_DW.Delay_DSTATE_f = ERR_INIT_PRECHARGE;\r\n      }\r\n      break;\r\n\r\n     case controller_IN_PrechargeState:\r\n      controller_DW.Delay_DSTATE_f = PRECHARGE;\r\n      if ((controller_U.BM_b_prechrgContactorSts == 0.0) &&\r\n          (controller_U.BM_b_HVnegContactorSts == 1.0) &&\r\n          (controller_U.BM_b_HVposContactorSts == 1.0)) {\r\n        controller_DW.is_c3_battery_monitor_lib = controller_IN_RunningState;\r\n        controller_DW.temporalCounter_i1_p = 0U;\r\n        controller_DW.Delay_DSTATE_f = BM_RUNNING;\r\n      } else if (controller_DW.temporalCounter_i1_p >= 5U) {\r\n        controller_DW.is_c3_battery_monitor_lib =\r\n          controll_IN_ErrorPrechargeState;\r\n        controller_DW.Delay_DSTATE_f = ERR_PRECHARGE;\r\n      }\r\n      break;\r\n\r\n     case controller_IN_RunningState:\r\n      controller_DW.Delay_DSTATE_f = BM_RUNNING;\r\n      if ((controller_U.BM_b_prechrgContactorSts == 0.0) &&\r\n          (controller_U.BM_b_HVnegContactorSts == 1.0) &&\r\n          (controller_U.BM_b_HVposContactorSts == 1.0)) {\r\n        controller_DW.is_c3_battery_monitor_lib = controller_IN_RunningState;\r\n        controller_DW.temporalCounter_i1_p = 0U;\r\n        controller_DW.Delay_DSTATE_f = BM_RUNNING;\r\n      } else if (controller_DW.temporalCounter_i1_p >= 5U) {\r\n        controller_DW.is_c3_battery_monitor_lib =\r\n          controller_IN_ErrorRunningState;\r\n        controller_DW.Delay_DSTATE_f = ERR_RUNNING;\r\n      }\r\n      break;\r\n\r\n     case controller_IN_StartupState:\r\n      controller_DW.Delay_DSTATE_f = BM_STARTUP;\r\n      if ((controller_U.BM_b_prechrgContactorSts == 1.0) &&\r\n          (controller_U.BM_b_HVnegContactorSts == 1.0) &&\r\n          (controller_U.BM_b_HVposContactorSts == 0.0)) {\r\n        controller_DW.is_c3_battery_monitor_lib =\r\n          con_IN_InitializePrechargeState;\r\n        controller_DW.temporalCounter_i1_p = 0U;\r\n        controller_DW.Delay_DSTATE_f = INIT_PRECHARGE;\r\n      } else if (controller_DW.temporalCounter_i1_p >= 5U) {\r\n        controller_DW.is_c3_battery_monitor_lib =\r\n          controller_IN_ErrorStartupState;\r\n        controller_DW.Delay_DSTATE_f = ERR_STARTUP;\r\n      }\r\n      break;\r\n\r\n     default:\r\n      /* case IN_StartupState1: */\r\n      controller_DW.Delay_DSTATE_f = BM_IDLE;\r\n      if ((controller_U.BM_b_prechrgContactorSts == 0.0) &&\r\n          (controller_U.BM_b_HVnegContactorSts == 1.0) &&\r\n          (controller_U.BM_b_HVposContactorSts == 0.0)) {\r\n        controller_DW.is_c3_battery_monitor_lib = controller_IN_StartupState;\r\n        controller_DW.temporalCounter_i1_p = 0U;\r\n        controller_DW.Delay_DSTATE_f = BM_STARTUP;\r\n      }\r\n      break;\r\n    }\r\n  }\r\n\r\n  /* End of Chart: '<S1>/Chart' */\r\n\r\n  /* Switch: '<S4>/Switch' incorporates:\r\n   *  Constant: '<S4>/Constant'\r\n   *  Constant: '<S4>/Constant1'\r\n   *  Delay: '<S3>/Delay1'\r\n   *  RelationalOperator: '<S4>/motorErrorActive'\r\n   *  Switch: '<S4>/Switch1'\r\n   */\r\n  if (controller_B.MI_motorStatus == MI_STS_ERROR) {\r\n    controller_DW.Delay1_DSTATE = MI_STS_ERROR;\r\n  } else {\r\n    controller_DW.Delay1_DSTATE = controller_B.MI_motorStatus;\r\n  }\r\n\r\n  /* End of Switch: '<S4>/Switch' */\r\n}\r\n\r\n/* Model initialize function */\r\nvoid controller_initialize(void)\r\n{\r\n  /* (no initialization code required) */\r\n}\r\n\r\n/* Model terminate function */\r\nvoid controller_terminate(void)\r\n{\r\n  /* (no terminate code required) */\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"controller.h","type":"header","group":"model","path":"C:\\Users\\Abhishek\\Downloads\\Formula\\git\\vehicle_control_system\\src\\controller_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: controller.h\r\n *\r\n * Code generated for Simulink model 'controller'.\r\n *\r\n * Model version                  : 1.9\r\n * Simulink Coder version         : 9.8 (R2022b) 13-May-2022\r\n * C/C++ source code generated on : Sat Jan 28 16:12:49 2023\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_controller_h_\r\n#define RTW_HEADER_controller_h_\r\n#ifndef controller_COMMON_INCLUDES_\r\n#define controller_COMMON_INCLUDES_\r\n#include \"rtwtypes.h\"\r\n#endif                                 /* controller_COMMON_INCLUDES_ */\r\n\r\n#include \"controller_types.h\"\r\n\r\n/* Macros for accessing real-time model data structure */\r\n#ifndef rtmGetErrorStatus\r\n#define rtmGetErrorStatus(rtm)         ((rtm)->errorStatus)\r\n#endif\r\n\r\n#ifndef rtmSetErrorStatus\r\n#define rtmSetErrorStatus(rtm, val)    ((rtm)->errorStatus = (val))\r\n#endif\r\n\r\n/* Block signals (default storage) */\r\ntypedef struct {\r\n  real32_T AMK_TorqueLimitPositiv;     /* '<S4>/RIGHT_MOTOR' */\r\n  real32_T AMK_TorqueLimitNegativ;     /* '<S4>/RIGHT_MOTOR' */\r\n  MI_STATUSES MI_motorStatus;          /* '<S4>/RIGHT_MOTOR' */\r\n  MI_CMD GOV_e_miCmd;                  /* '<S3>/Chart' */\r\n  DI_CMD GOV_e_diCmd;                  /* '<S3>/Chart' */\r\n  boolean_T b_ReadyToDrive;            /* '<S2>/Chart' */\r\n} B_controller_T;\r\n\r\n/* Block states (default storage) for system '<Root>' */\r\ntypedef struct {\r\n  MI_STATUSES Delay1_DSTATE;           /* '<S3>/Delay1' */\r\n  BM_STATUSES Delay_DSTATE_f;          /* '<S3>/Delay' */\r\n  DI_STATUSES Delay2_DSTATE;           /* '<S3>/Delay2' */\r\n  uint16_T motorStartCount;            /* '<S3>/Chart' */\r\n  uint8_T is_c3_motor_interface_lib;   /* '<S4>/RIGHT_MOTOR' */\r\n  uint8_T is_AMK_startup;              /* '<S4>/RIGHT_MOTOR' */\r\n  uint8_T is_AMK_errorReset;           /* '<S4>/RIGHT_MOTOR' */\r\n  uint8_T is_AMK_shutdown;             /* '<S4>/RIGHT_MOTOR' */\r\n  uint8_T is_active_c3_motor_interface_li;/* '<S4>/RIGHT_MOTOR' */\r\n  uint8_T temporalCounter_i1;          /* '<S4>/RIGHT_MOTOR' */\r\n  uint8_T is_c3_governor_lib;          /* '<S3>/Chart' */\r\n  uint8_T is_STARTUP;                  /* '<S3>/Chart' */\r\n  uint8_T is_STARTUP_ERROR;            /* '<S3>/Chart' */\r\n  uint8_T is_RUNNING_ERROR;            /* '<S3>/Chart' */\r\n  uint8_T is_active_c3_governor_lib;   /* '<S3>/Chart' */\r\n  uint8_T is_c3_driver_interface_lib;  /* '<S2>/Chart' */\r\n  uint8_T is_DI_running;               /* '<S2>/Chart' */\r\n  uint8_T is_Ready_to_drive;           /* '<S2>/Chart' */\r\n  uint8_T is_active_c3_driver_interface_l;/* '<S2>/Chart' */\r\n  uint8_T temporalCounter_i1_a;        /* '<S2>/Chart' */\r\n  uint8_T is_c3_battery_monitor_lib;   /* '<S1>/Chart' */\r\n  uint8_T is_active_c3_battery_monitor_li;/* '<S1>/Chart' */\r\n  uint8_T temporalCounter_i1_p;        /* '<S1>/Chart' */\r\n} DW_controller_T;\r\n\r\n/* Invariant block signals (default storage) */\r\ntypedef struct {\r\n  const real32_T Gain1;                /* '<S5>/Gain1' */\r\n} ConstB_controller_T;\r\n\r\n/* Constant parameters (default storage) */\r\ntypedef struct {\r\n  /* Pooled Parameter (Expression: [0 5 10 15 20 25 30 35 40 45 50 55 60 65 70 75 80 85 90 95 100])\r\n   * Referenced by: '<S2>/AccelPedalPos1 LUT'\r\n   */\r\n  real32_T pooled3[21];\r\n} ConstP_controller_T;\r\n\r\n/* External inputs (root inport signals with default storage) */\r\ntypedef struct {\r\n  boolean_T AMK_bReserve;              /* '<Root>/AMK_bReserve' */\r\n  real32_T DI_V_SteeringAngle;         /* '<Root>/DI_V_SteeringAngle' */\r\n  real32_T DI_V_BrakePedalPos;         /* '<Root>/DI_V_BrakePedalPos' */\r\n  real_T DI_b_DriverButton;            /* '<Root>/DI_b_DriverButton' */\r\n  real32_T DI_V_AccelPedalPos1;        /* '<Root>/DI_V_AccelPedalPos1' */\r\n  real32_T DI_V_AccelPedalPos2;        /* '<Root>/DI_V_AccelPedalPos2' */\r\n  real_T BM_b_prechrgContactorSts;     /* '<Root>/BM_b_prechrgContactorSts' */\r\n  real_T BM_b_HVposContactorSts;       /* '<Root>/BM_b_HVposContactorSts' */\r\n  real_T BM_b_HVnegContactorSts;       /* '<Root>/BM_b_HVnegContactorSts' */\r\n  boolean_T AMK_bSystemReady;          /* '<Root>/AMK_bSystemReady' */\r\n  boolean_T AMK_bError;                /* '<Root>/AMK_bError' */\r\n  boolean_T AMK_bWarn;                 /* '<Root>/AMK_bWarn' */\r\n  boolean_T AMK_bQuitDcOn;             /* '<Root>/AMK_bQuitDcOn' */\r\n  boolean_T AMK_bDcOn;                 /* '<Root>/AMK_bDcOn' */\r\n  boolean_T AMK_bQuitInverterOn;       /* '<Root>/AMK_bQuitInverterOn' */\r\n  boolean_T AMK_bInverterOn;           /* '<Root>/AMK_bInverterOn' */\r\n  boolean_T AMK_bDerating;             /* '<Root>/AMK_bDerating' */\r\n  int16_T AMK_TempMotor;               /* '<Root>/AMK_TempMotor' */\r\n  int16_T AMK_TempInverter;            /* '<Root>/AMK_TempInverter' */\r\n  uint16_T AMK_ErrorInfo;              /* '<Root>/AMK_ErrorInfo' */\r\n  int16_T AMK_TempIGBT;                /* '<Root>/AMK_TempIGBT' */\r\n  int16_T AMK_ActualVelocity;          /* '<Root>/AMK_ActualVelocity' */\r\n  int16_T AMK_TorqueCurrent;           /* '<Root>/AMK_TorqueCurrent' */\r\n  int16_T AMK_MagnetizingCurrent;      /* '<Root>/AMK_MagnetizingCurrent' */\r\n} ExtU_controller_T;\r\n\r\n/* External outputs (root outports fed by signals with default storage) */\r\ntypedef struct {\r\n  real32_T ptCAN_AMK_Setpoints1_Left;  /* '<Root>/ptCAN_AMK_Setpoints1_Left' */\r\n  boolean_T DI_b_driverSpeaker;        /* '<Root>/DI_b_driverSpeaker' */\r\n  uint8_T AMK_bInverterOn_tx;          /* '<Root>/AMK_bInverterOn_tx' */\r\n  uint8_T AMK_bDcOn_tx;                /* '<Root>/AMK_bDcOn_tx' */\r\n  uint8_T AMK_bEnable;                 /* '<Root>/AMK_bEnable' */\r\n  uint8_T AMK_bErrorReset;             /* '<Root>/AMK_bErrorReset' */\r\n  real32_T AMK_TargetVelocity;         /* '<Root>/AMK_TargetVelocity' */\r\n  real32_T AMK_TorqueLimitPositiv;     /* '<Root>/AMK_TorqueLimitPositiv' */\r\n  real32_T AMK_TorqueLimitNegativ;     /* '<Root>/AMK_TorqueLimitNegativ' */\r\n} ExtY_controller_T;\r\n\r\n/* Real-time Model Data Structure */\r\nstruct tag_RTM_controller_T {\r\n  const char_T * volatile errorStatus;\r\n};\r\n\r\n/* Block signals (default storage) */\r\nextern B_controller_T controller_B;\r\n\r\n/* Block states (default storage) */\r\nextern DW_controller_T controller_DW;\r\n\r\n/* External inputs (root inport signals with default storage) */\r\nextern ExtU_controller_T controller_U;\r\n\r\n/* External outputs (root outports fed by signals with default storage) */\r\nextern ExtY_controller_T controller_Y;\r\nextern const ConstB_controller_T controller_ConstB;/* constant block i/o */\r\n\r\n/* Constant parameters (default storage) */\r\nextern const ConstP_controller_T controller_ConstP;\r\n\r\n/* Model entry point functions */\r\nextern void controller_initialize(void);\r\nextern void controller_step(void);\r\nextern void controller_terminate(void);\r\n\r\n/* Real-time Model object */\r\nextern RT_MODEL_controller_T *const controller_M;\r\n\r\n/*-\r\n * These blocks were eliminated from the model due to optimizations:\r\n *\r\n * Block '<Root>/Constant1' : Unused code path elimination\r\n * Block '<Root>/Constant2' : Unused code path elimination\r\n * Block '<S2>/AND' : Unused code path elimination\r\n * Block '<S2>/Constant2' : Unused code path elimination\r\n * Block '<S2>/OR' : Unused code path elimination\r\n * Block '<S2>/Switch1' : Unused code path elimination\r\n * Block '<S15>/FixPt Data Type Duplicate' : Unused code path elimination\r\n * Block '<S15>/FixPt Logical Operator' : Unused code path elimination\r\n * Block '<S15>/Lower Test' : Unused code path elimination\r\n * Block '<S15>/Upper Test' : Unused code path elimination\r\n * Block '<S11>/LowerPotentiometerLimit1' : Unused code path elimination\r\n * Block '<S17>/FixPt Data Type Duplicate' : Unused code path elimination\r\n * Block '<S19>/FixPt Data Type Duplicate' : Unused code path elimination\r\n * Block '<S14>/Gain' : Unused code path elimination\r\n * Block '<S21>/FixPt Data Type Duplicate' : Unused code path elimination\r\n * Block '<S21>/FixPt Logical Operator' : Unused code path elimination\r\n * Block '<S21>/Lower Test' : Unused code path elimination\r\n * Block '<S21>/Upper Test' : Unused code path elimination\r\n * Block '<S14>/LowerPotentiometerLimit1' : Unused code path elimination\r\n * Block '<S14>/UpperPotentiometerLimit1' : Unused code path elimination\r\n * Block '<S22>/Divide' : Unused code path elimination\r\n * Block '<S22>/Subtract' : Unused code path elimination\r\n * Block '<S5>/MaxAMKspeed1' : Unused code path elimination\r\n * Block '<S5>/MaxBatteryCurrent1' : Unused code path elimination\r\n * Block '<S5>/MaxBatteryCurrent2' : Unused code path elimination\r\n * Block '<S5>/MaxBatteryCurrent3' : Unused code path elimination\r\n * Block '<S5>/NegTorqueLimit1' : Unused code path elimination\r\n * Block '<S28>/Constant1' : Unused code path elimination\r\n * Block '<S29>/Constant' : Unused code path elimination\r\n * Block '<S31>/Constant' : Unused code path elimination\r\n * Block '<S5>/convertToAmps' : Unused code path elimination\r\n * Block '<S5>/convertToAmps1' : Unused code path elimination\r\n * Block '<S5>/convertToAmps2' : Unused code path elimination\r\n * Block '<S5>/latAccel' : Unused code path elimination\r\n * Block '<S5>/longAccel' : Unused code path elimination\r\n */\r\n\r\n/*-\r\n * The generated code includes comments that allow you to trace directly\r\n * back to the appropriate location in the model.  The basic format\r\n * is <system>/block_name, where system is the system number (uniquely\r\n * assigned by Simulink) and block_name is the name of the block.\r\n *\r\n * Use the MATLAB hilite_system command to trace the generated code back\r\n * to the model.  For example,\r\n *\r\n * hilite_system('<S3>')    - opens system 3\r\n * hilite_system('<S3>/Kp') - opens and selects block Kp which resides in S3\r\n *\r\n * Here is the system hierarchy for this model\r\n *\r\n * '<Root>' : 'controller'\r\n * '<S1>'   : 'controller/battery_monitor'\r\n * '<S2>'   : 'controller/driver_interface'\r\n * '<S3>'   : 'controller/governor'\r\n * '<S4>'   : 'controller/motor_interface'\r\n * '<S5>'   : 'controller/vehicle_dynamics'\r\n * '<S6>'   : 'controller/battery_monitor/Chart'\r\n * '<S7>'   : 'controller/driver_interface/Chart'\r\n * '<S8>'   : 'controller/driver_interface/If Action Subsystem'\r\n * '<S9>'   : 'controller/driver_interface/If Action Subsystem1'\r\n * '<S10>'  : 'controller/driver_interface/If Action Subsystem2'\r\n * '<S11>'  : 'controller/driver_interface/potentiometerProcessing'\r\n * '<S12>'  : 'controller/driver_interface/potentiometerProcessing1'\r\n * '<S13>'  : 'controller/driver_interface/potentiometerProcessing2'\r\n * '<S14>'  : 'controller/driver_interface/potentiometerProcessing3'\r\n * '<S15>'  : 'controller/driver_interface/potentiometerProcessing/Interval Test Dynamic'\r\n * '<S16>'  : 'controller/driver_interface/potentiometerProcessing/convertToPercent'\r\n * '<S17>'  : 'controller/driver_interface/potentiometerProcessing1/Interval Test Dynamic'\r\n * '<S18>'  : 'controller/driver_interface/potentiometerProcessing1/convertToPercent'\r\n * '<S19>'  : 'controller/driver_interface/potentiometerProcessing2/Interval Test Dynamic'\r\n * '<S20>'  : 'controller/driver_interface/potentiometerProcessing2/convertToPercent'\r\n * '<S21>'  : 'controller/driver_interface/potentiometerProcessing3/Interval Test Dynamic'\r\n * '<S22>'  : 'controller/driver_interface/potentiometerProcessing3/convertToPercent'\r\n * '<S23>'  : 'controller/governor/Chart'\r\n * '<S24>'  : 'controller/motor_interface/RIGHT_MOTOR'\r\n * '<S25>'  : 'controller/motor_interface/convertToAmps'\r\n * '<S26>'  : 'controller/motor_interface/convertToAmps1'\r\n * '<S27>'  : 'controller/vehicle_dynamics/RIGHT_LIMIT'\r\n * '<S28>'  : 'controller/vehicle_dynamics/TorqueVectoring'\r\n * '<S29>'  : 'controller/vehicle_dynamics/TractionControlSystem_LEFT'\r\n * '<S30>'  : 'controller/vehicle_dynamics/TractionControlSystem_RIGHT'\r\n * '<S31>'  : 'controller/vehicle_dynamics/VelocityEstimation'\r\n */\r\n#endif                                 /* RTW_HEADER_controller_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"controller_private.h","type":"header","group":"model","path":"C:\\Users\\Abhishek\\Downloads\\Formula\\git\\vehicle_control_system\\src\\controller_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: controller_private.h\r\n *\r\n * Code generated for Simulink model 'controller'.\r\n *\r\n * Model version                  : 1.9\r\n * Simulink Coder version         : 9.8 (R2022b) 13-May-2022\r\n * C/C++ source code generated on : Sat Jan 28 16:12:49 2023\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_controller_private_h_\r\n#define RTW_HEADER_controller_private_h_\r\n#include \"rtwtypes.h\"\r\n#include \"controller_types.h\"\r\n#include \"controller.h\"\r\n#ifndef UCHAR_MAX\r\n#include <limits.h>\r\n#endif\r\n\r\n#if ( UCHAR_MAX != (0xFFU) ) || ( SCHAR_MAX != (0x7F) )\r\n#error Code was generated for compiler with different sized uchar/char. \\\r\nConsider adjusting Test hardware word size settings on the \\\r\nHardware Implementation pane to match your compiler word sizes as \\\r\ndefined in limits.h of the compiler. Alternatively, you can \\\r\nselect the Test hardware is the same as production hardware option and \\\r\nselect the Enable portable word sizes option on the Code Generation > \\\r\nVerification pane for ERT based targets, which will disable the \\\r\npreprocessor word size checks.\r\n#endif\r\n\r\n#if ( USHRT_MAX != (0xFFFFU) ) || ( SHRT_MAX != (0x7FFF) )\r\n#error Code was generated for compiler with different sized ushort/short. \\\r\nConsider adjusting Test hardware word size settings on the \\\r\nHardware Implementation pane to match your compiler word sizes as \\\r\ndefined in limits.h of the compiler. Alternatively, you can \\\r\nselect the Test hardware is the same as production hardware option and \\\r\nselect the Enable portable word sizes option on the Code Generation > \\\r\nVerification pane for ERT based targets, which will disable the \\\r\npreprocessor word size checks.\r\n#endif\r\n\r\n#if ( UINT_MAX != (0xFFFFFFFFU) ) || ( INT_MAX != (0x7FFFFFFF) )\r\n#error Code was generated for compiler with different sized uint/int. \\\r\nConsider adjusting Test hardware word size settings on the \\\r\nHardware Implementation pane to match your compiler word sizes as \\\r\ndefined in limits.h of the compiler. Alternatively, you can \\\r\nselect the Test hardware is the same as production hardware option and \\\r\nselect the Enable portable word sizes option on the Code Generation > \\\r\nVerification pane for ERT based targets, which will disable the \\\r\npreprocessor word size checks.\r\n#endif\r\n\r\n#if ( ULONG_MAX != (0xFFFFFFFFU) ) || ( LONG_MAX != (0x7FFFFFFF) )\r\n#error Code was generated for compiler with different sized ulong/long. \\\r\nConsider adjusting Test hardware word size settings on the \\\r\nHardware Implementation pane to match your compiler word sizes as \\\r\ndefined in limits.h of the compiler. Alternatively, you can \\\r\nselect the Test hardware is the same as production hardware option and \\\r\nselect the Enable portable word sizes option on the Code Generation > \\\r\nVerification pane for ERT based targets, which will disable the \\\r\npreprocessor word size checks.\r\n#endif\r\n\r\nextern real32_T look1_iflf_binlxpw(real32_T u0, const real32_T bp0[], const\r\n  real32_T table[], uint32_T maxIndex);\r\n\r\n#endif                                 /* RTW_HEADER_controller_private_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"controller_types.h","type":"header","group":"model","path":"C:\\Users\\Abhishek\\Downloads\\Formula\\git\\vehicle_control_system\\src\\controller_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: controller_types.h\r\n *\r\n * Code generated for Simulink model 'controller'.\r\n *\r\n * Model version                  : 1.9\r\n * Simulink Coder version         : 9.8 (R2022b) 13-May-2022\r\n * C/C++ source code generated on : Sat Jan 28 16:12:49 2023\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_controller_types_h_\r\n#define RTW_HEADER_controller_types_h_\r\n#include \"rtwtypes.h\"\r\n#ifndef DEFINED_TYPEDEF_FOR_MI_STATUSES_\r\n#define DEFINED_TYPEDEF_FOR_MI_STATUSES_\r\n\r\ntypedef enum {\r\n  UNKNOWN = 0,                         /* Default value */\r\n  STS_INIT,\r\n  STARTUP,\r\n  RUNNING,\r\n  SHUTDOWN,\r\n  MI_STS_ERROR,\r\n  OFF\r\n} MI_STATUSES;\r\n\r\n#endif\r\n\r\n#ifndef DEFINED_TYPEDEF_FOR_BM_STATUSES_\r\n#define DEFINED_TYPEDEF_FOR_BM_STATUSES_\r\n\r\ntypedef enum {\r\n  BM_UNKNOWN = 0,                      /* Default value */\r\n  BM_INIT,\r\n  BM_IDLE,\r\n  BM_STARTUP,\r\n  INIT_PRECHARGE,\r\n  PRECHARGE,\r\n  BM_RUNNING,\r\n  ERR_PRECHARGE_CLOSED,\r\n  ERR_STARTUP,\r\n  ERR_INIT_PRECHARGE,\r\n  ERR_PRECHARGE,\r\n  ERR_RUNNING,\r\n  ERR_ALL_CLOSED,\r\n  ERR_HV_POSITIVE\r\n} BM_STATUSES;\r\n\r\n#endif\r\n\r\n#ifndef DEFINED_TYPEDEF_FOR_DI_CMD_\r\n#define DEFINED_TYPEDEF_FOR_DI_CMD_\r\n\r\ntypedef enum {\r\n  DI_CMD_INIT = 0,                     /* Default value */\r\n  READY_TO_DRIVE,\r\n  SYSTEM_ERROR,\r\n  DI_ERR_RESET\r\n} DI_CMD;\r\n\r\n#endif\r\n\r\n#ifndef DEFINED_TYPEDEF_FOR_DI_STATUSES_\r\n#define DEFINED_TYPEDEF_FOR_DI_STATUSES_\r\n\r\ntypedef enum {\r\n  DI_UNKNOWN = 0,                      /* Default value */\r\n  DI_STS_INIT,\r\n  DI_IDLE,\r\n  DI_STARTUP,\r\n  WAITING_FOR_DRVR,\r\n  DRV_START_REQ,\r\n  DI_RUNNING,\r\n  DI_ERROR\r\n} DI_STATUSES;\r\n\r\n#endif\r\n\r\n#ifndef DEFINED_TYPEDEF_FOR_MI_CMD_\r\n#define DEFINED_TYPEDEF_FOR_MI_CMD_\r\n\r\ntypedef enum {\r\n  CMD_INIT = 0,                        /* Default value */\r\n  IDLE,\r\n  CMD_STARTUP,\r\n  CMD_SHUTDOWN,\r\n  ERR_RESET\r\n} MI_CMD;\r\n\r\n#endif\r\n\r\n/* Forward declaration for rtModel */\r\ntypedef struct tag_RTM_controller_T RT_MODEL_controller_T;\r\n\r\n#endif                                 /* RTW_HEADER_controller_types_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"controller_data.c","type":"source","group":"data","path":"C:\\Users\\Abhishek\\Downloads\\Formula\\git\\vehicle_control_system\\src\\controller_ert_rtw","tag":"","groupDisplay":"Data files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: controller_data.c\r\n *\r\n * Code generated for Simulink model 'controller'.\r\n *\r\n * Model version                  : 1.9\r\n * Simulink Coder version         : 9.8 (R2022b) 13-May-2022\r\n * C/C++ source code generated on : Sat Jan 28 16:12:49 2023\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"controller.h\"\r\n\r\n/* Invariant block signals (default storage) */\r\nconst ConstB_controller_T controller_ConstB = {\r\n  50.0F                                /* '<S5>/Gain1' */\r\n};\r\n\r\n/* Constant parameters (default storage) */\r\nconst ConstP_controller_T controller_ConstP = {\r\n  /* Pooled Parameter (Expression: [0 5 10 15 20 25 30 35 40 45 50 55 60 65 70 75 80 85 90 95 100])\r\n   * Referenced by: '<S2>/AccelPedalPos1 LUT'\r\n   */\r\n  { 0.0F, 5.0F, 10.0F, 15.0F, 20.0F, 25.0F, 30.0F, 35.0F, 40.0F, 45.0F, 50.0F,\r\n    55.0F, 60.0F, 65.0F, 70.0F, 75.0F, 80.0F, 85.0F, 90.0F, 95.0F, 100.0F }\r\n};\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtwtypes.h","type":"header","group":"utility","path":"C:\\Users\\Abhishek\\Downloads\\Formula\\git\\vehicle_control_system\\src\\controller_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: rtwtypes.h\r\n *\r\n * Code generated for Simulink model 'controller'.\r\n *\r\n * Model version                  : 1.9\r\n * Simulink Coder version         : 9.8 (R2022b) 13-May-2022\r\n * C/C++ source code generated on : Sat Jan 28 16:12:49 2023\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTWTYPES_H\r\n#define RTWTYPES_H\r\n\r\n/* Logical type definitions */\r\n#if (!defined(__cplusplus))\r\n#ifndef false\r\n#define false                          (0U)\r\n#endif\r\n\r\n#ifndef true\r\n#define true                           (1U)\r\n#endif\r\n#endif\r\n\r\n/*=======================================================================*\r\n * Target hardware information\r\n *   Device type: Intel->x86-64 (Windows64)\r\n *   Number of bits:     char:   8    short:   16    int:  32\r\n *                       long:  32\r\n *                       native word size:  64\r\n *   Byte ordering: LittleEndian\r\n *   Signed integer division rounds to: Zero\r\n *   Shift right on a signed integer as arithmetic shift: on\r\n *=======================================================================*/\r\n\r\n/*=======================================================================*\r\n * Fixed width word size data types:                                     *\r\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n *   real32_T, real64_T           - 32 and 64 bit floating point numbers *\r\n *=======================================================================*/\r\ntypedef signed char int8_T;\r\ntypedef unsigned char uint8_T;\r\ntypedef short int16_T;\r\ntypedef unsigned short uint16_T;\r\ntypedef int int32_T;\r\ntypedef unsigned int uint32_T;\r\ntypedef float real32_T;\r\ntypedef double real64_T;\r\n\r\n/*===========================================================================*\r\n * Generic type definitions: boolean_T, char_T, byte_T, int_T, uint_T,       *\r\n *                           real_T, time_T, ulong_T.                        *\r\n *===========================================================================*/\r\ntypedef double real_T;\r\ntypedef double time_T;\r\ntypedef unsigned char boolean_T;\r\ntypedef int int_T;\r\ntypedef unsigned int uint_T;\r\ntypedef unsigned long ulong_T;\r\ntypedef char char_T;\r\ntypedef unsigned char uchar_T;\r\ntypedef char_T byte_T;\r\n\r\n/*===========================================================================*\r\n * Complex number type definitions                                           *\r\n *===========================================================================*/\r\n#define CREAL_T\r\n\r\ntypedef struct {\r\n  real32_T re;\r\n  real32_T im;\r\n} creal32_T;\r\n\r\ntypedef struct {\r\n  real64_T re;\r\n  real64_T im;\r\n} creal64_T;\r\n\r\ntypedef struct {\r\n  real_T re;\r\n  real_T im;\r\n} creal_T;\r\n\r\n#define CINT8_T\r\n\r\ntypedef struct {\r\n  int8_T re;\r\n  int8_T im;\r\n} cint8_T;\r\n\r\n#define CUINT8_T\r\n\r\ntypedef struct {\r\n  uint8_T re;\r\n  uint8_T im;\r\n} cuint8_T;\r\n\r\n#define CINT16_T\r\n\r\ntypedef struct {\r\n  int16_T re;\r\n  int16_T im;\r\n} cint16_T;\r\n\r\n#define CUINT16_T\r\n\r\ntypedef struct {\r\n  uint16_T re;\r\n  uint16_T im;\r\n} cuint16_T;\r\n\r\n#define CINT32_T\r\n\r\ntypedef struct {\r\n  int32_T re;\r\n  int32_T im;\r\n} cint32_T;\r\n\r\n#define CUINT32_T\r\n\r\ntypedef struct {\r\n  uint32_T re;\r\n  uint32_T im;\r\n} cuint32_T;\r\n\r\n/*=======================================================================*\r\n * Min and Max:                                                          *\r\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n *=======================================================================*/\r\n#define MAX_int8_T                     ((int8_T)(127))\r\n#define MIN_int8_T                     ((int8_T)(-128))\r\n#define MAX_uint8_T                    ((uint8_T)(255U))\r\n#define MAX_int16_T                    ((int16_T)(32767))\r\n#define MIN_int16_T                    ((int16_T)(-32768))\r\n#define MAX_uint16_T                   ((uint16_T)(65535U))\r\n#define MAX_int32_T                    ((int32_T)(2147483647))\r\n#define MIN_int32_T                    ((int32_T)(-2147483647-1))\r\n#define MAX_uint32_T                   ((uint32_T)(0xFFFFFFFFU))\r\n\r\n/* Block D-Work pointer type */\r\ntypedef void * pointer_T;\r\n\r\n#endif                                 /* RTWTYPES_H */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"}],"coverage":[{"id":"SimulinkCoverage","name":"Simulink Coverage","files":[]},{"id":"Bullseye","name":"Bullseye Coverage","files":[]},{"id":"LDRA","name":"LDRA Testbed","files":[]}],"features":{"annotation":false,"coverage":true,"profiling":true,"tooltip":true,"coverageTooltip":false,"showJustificationLinks":false,"showProfilingInfo":false,"showTaskSummary":false}};